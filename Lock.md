# 锁机制
## 说说线程安全问题
```
线程安全是指要控制多个线程对某个资源的有序访问或修改,而在这些线程之间没有产生冲突。线程安全一般体现在两个方面：
	多个thread对同一个Java实例的访问（read和modify）不会相互干扰，它主要体现在关键字synchronize。对ArrayList和Vector，HashMap和Hashtable（后者每个方法前都有synchronize关键字）。如果你在interator一个List对象时，其他线程remove一个element，问题就出现了

每个线程都有自己的字段，而不会在多个线程之间共享。它主要体现在java.lang.ThreadLocal类，而没有Java关键字支持，如像static、transient那样。 
```



## volatile 实现原理
```
Volatile 是轻量级的 synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。
```
- 共享变量
```
在多个线程之间能够被共享的变量被称作共享变量。共享变量包括所有的实例变量、静态变量和数组元素。他们都被存放在堆内存中，Volatile只作用于共享变量。
```

- 内存屏障   （Memory Barriers）
```
是一组处理器指令
```
-  

* synchronize 实现原理
* synchronized 与 lock 的区别
* 
##CAS 乐观锁
```
乐观锁是一种思想，即认为读多写少，遇到并发写的可能性比较低，所以采取在写时先读出当前版本号,然后加锁的操作（比较跟上一次的版本号,如果一样则更新），如果失败则要重复读--比较-写的操作。

CAS是一种更新的原子操作，比较当前值跟传入值是否一样，一样则更新，否则失败


```

## 乐观锁的业务场景及实现方式
```
每次获取数据的时候，都不会担心数据被修改，所以每次获取数据的时候都不会进行加锁,但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。
```

- 应用场景
```
比较适合读取操作比较频繁的场景，如果出现大量的数据写入操作，数据发生冲突的可能性比较大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作,降低了系统的吞吐量。
```